---
layout: single
title: "MVVM Light binding to iOS UITableViews with Xamarin"
title: MVVM Light binding to iOS UITableViews with Xamarin
date: 2015-10-21
tags: ["MVVM Light", "iOS", "Mobile", "Xamarin"]
slug: "mvvm-light-ios-uitableview-binding"
---

[![showing the running sample app]({{ site.url }}{{ site.baseurl }}/images/6f31c5c9-3bf3-4015-8ffe-491a2c225a83.png "showing the running sample app")]({{ site.url }}{{ site.baseurl }}/images/91fcaaaa-f740-4536-b555-e45c25249ee7.png)

This post will focus specifically on how to bind collection of data to a view. In another post I already focused on how to use bindings for data entry, be sure to read that one to get more insight into data binding under iOS with MVVM Light. In this post we will display a list of people using the standard <font face="Consolas">UITableView</font> iOS UI control. Via two buttons we will be able to add or remove a person. The people will be randomly generated by a service but first things first. Let’s start by creating the view.

# Model

The people are generate with the help of the <font face="Consolas">NameGenerator.cs</font>, which is a class that generates random first- and last names.


    // As found on https://digitaltoolfactory.net/blog/2012/04/how-to-make-a-random-name-generator-in-c/
    public static class NameGenerator
    {
        public static Random rnd = new Random();
    
        public static string GenRandomLastName()
        {
            List<string> lst = new List<string>();
            string str = string.Empty;
            lst.Add("Smith");
            // ...
    
            str = lst.OrderBy(xx => rnd.Next()).First();
            return str;
        }
        public static string GenRandomFirstName()
        {
            List<string> lst = new List<string>();
            string str = string.Empty;
            // male
            lst.Add("Aiden");
            // ...
    
            //female
    
            lst.Add("Sophia");
            // ...
    
            str = lst.OrderBy(xx => rnd.Next()).First();
            return str;
        }
    }


This class will be accessed form the view models, but let’s first setup the view.

# View

The view consists of a <font face="Consolas">UITableView</font> and two <font face="Consolas">UIButtons</font> which we add in the Storyboard and name them <font face="Consolas">PeopleTableView</font>, <font face="Consolas">AddPersonButton</font>and  <font face="Consolas">RemovePersonButton</font>.

[![showing designer when creating the iOS view]({{ site.url }}{{ site.baseurl }}/images/175318ef-bc3d-4e97-8bdb-402ca00c506b.png "showing designer when creating the iOS view")]({{ site.url }}{{ site.baseurl }}/images/1c06b541-7c02-4453-9432-b6d89cfb0f50.png)

After setting up the view next thing on the list is creating the view model.

# View Model

In the view model we implement an <font face="Consolas">ObservableCollection</font> to hold the list of people and two <font face="Consolas">RelayCommands</font> which when invoked add and remove a person from the list:


    public class MainViewModel : ViewModelBase
    {
        public MainViewModel()
        {
            AddPersonCommand = new RelayCommand(AddPerson);
            RemovePersonCommand = new RelayCommand(RemovePerson);
        }
    
        public RelayCommand AddPersonCommand { get; set; }
        public RelayCommand RemovePersonCommand { get; set; }
        public ObservableCollection<Person> People { get; private set; }
    
        public async Task InitAsync()
        {
            if (People != null) return;
    
            People = new ObservableCollection<Person>();
            var people = await InitPeopleList();
            foreach (var person in people)
            {
                People.Add(person);
            }
        }
    }


The list data is initialized asynchronously in an initialisation method. Now what is left to do is connect the view model with the view via bindings.

# Configuring Bindings

The bindings are setup in the <font face="Consolas">RootViewController.cs</font>, which is attached to the View which we are about to populate and interact with. The command bindings are implemented in the <font face="Consolas">ViewDidLoad</font> method:


    public override async void ViewDidLoad()
    {
        base.ViewDidLoad();
    
        await Vm.InitAsync();
    
        // Setup bindings
        AddPersonButton.SetCommand("TouchUpInside", Vm.AddPersonCommand);
        RemovePersonButton.SetCommand("TouchUpInside", Vm.RemovePersonCommand);
    }


The <font face="Consolas">UITableView</font>’s source is set in the <font face="Consolas">ViewWillAppear</font> method - if done in the <font face="Consolas">ViewDidLoad</font> method you will be initially showed nothing until you start scrolling the blank list.


    public override void ViewWillAppear(bool animated)
    {
        base.ViewWillAppear(animated);
    
        _tableViewController = Vm.People.GetController(CreatePersonCell, BindCellDelegate);
        _tableViewController.TableView = PeopleTableView;
    }


In the <font face="Consolas">CreatePersonCell</font> method the cell we will display gets created.:


    private UITableViewCell CreatePersonCell(NSString cellIdentifier)
    {
        return new UITableViewCell(UITableViewCellStyle.Default, "Gnabber");
    }



> In case you are wondering: “But what about cell recycling?”. Well there is some good news, MVVM Light takes care of that for you. That being said currently (version 5.1.1) does not support multiple cell templates for one collection.


The <font face="Consolas">BindCellDelegate</font> sets the content of the cell:


    private void BindCellDelegate(UITableViewCell cell, Person person, NSIndexPath path)
    {
        cell.TextLabel.Text = person.FullName;
    }


When all is setup we can start up the app you will be able to add and remove people to the list without having to react any further to the events or updating the table source any further.

# Conclusion

In this post you saw how you can bind a list of data to an iOS <font face="Consolas">UITableView</font>. Further demonstration showed how easy it is to change the content of the list and updating the UI with the new data. MVVM Light not only allows to integrate your view models nicely in under iOS but only provides some nice little helpers when it comes down to creating an iOS <font face="Consolas">TableSource</font>.

Thanks again to [Laurent Bugnion](http://www.galasoft.ch/) providing us with this great library.

You can find the whole sample on [GitHub](https://github.com/mallibone/MvvmLightSamples/tree/master/iOS/MvvmLightTableViewBindings.iOS "Link to sample on GitHub").
